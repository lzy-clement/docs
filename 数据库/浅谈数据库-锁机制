# <b>概览</b>
上一期讲到数据库事务，本来应该继续往下聊聊数据库事务的理解，但是由于在数据库事务的实现中，大部分是由锁来实现的，因此先用此篇幅来聊聊关于数据库锁。

同样的数据库锁也是数据库区别于文件系统的一个重要特性。它是保证数据库并发访问的一个重要特性，尽可能的最大程度使数据库可并发访问（对共享资源的并发访问），同时又确保每个用户能以一致的方式读取修改数据（这实际就是隔离级别的体现）。

InnoDB引擎采用的是行锁的粒度对数据进行锁操作。像MyISAM引擎采用的是表锁（读取没问题，插入性能差，除非每次从底部插入，还可以有一定的并发写入操作），SQL Server采用页锁等等。除了对数据上锁，还有很多其他的锁，如增删改操作缓冲池的LRU列表等。


# <b>锁的实现-lock与latch</b>
- latch为轻量级锁，是有时效性的（短时间的锁），由自己释放。又可以分为mutex（互斥）和rwlock（读写锁）。主要用来保证并发操作临界资源的正确性。
  - show engine innodb mutex可查看


- lock锁的对象是事务，用来锁定数据库中的对象，如表、页、行。在commit和rollback中释放锁。存在死锁机制（会对死锁的情况检测释放等）。
  - show engine innodb status 可查看
  - infomation_schema库下innodb_trx，innodb_locks，innodb_lock_waits表

# 锁的类型
InnoDB有两种标准的行级锁：
- 共享锁（S）：允许事务读一行数据
- 排他锁（X）：允许事务删除更新一行数据


1. 事务T1获取行1的S锁，事务T2可以继续获取行1的S锁，这是锁兼容
2. 继续1的情况，事务T3想获取X锁，必须等待T1，T2释放S锁

除了上面的两种锁以外，InnoDB支持更多粒度的锁，称为意向锁。这种意向锁允许存在行级的
